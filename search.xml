<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中==和equals的区别</title>
      <link href="/2020/9/"/>
      <url>/2020/9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://www.cnblogs.com/blueskyli/p/9932017.html" target="_blank" rel="noopener">Java中equals和==的区别</a></p></blockquote><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><strong>== 比较的是\</strong>变量(栈)内存中存放的对象的(堆)内存地址，*<em>用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。*</em></p><p><strong><em>\</em>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。**</strong></p><p>java中的数据类型可以分为两类：</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>byte,short,char,int,long,float,double,boolean</p><p>基本数据类型之间的比较需要用双等号（==），因为他们比较的是值</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>接口、类、数组等非基本数据类型</p><p>Java中的字符串String属于引用数据类型。因为String是一个类</p><p>当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为没new一次就会重新开辟一个新的堆内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Entity entity = <span class="keyword">new</span> Entity();</span><br><span class="line">Entity entity1 = <span class="keyword">new</span> Entity();</span><br><span class="line">Entity entity2 = entity;</span><br><span class="line">        </span><br><span class="line">System.out.println(entity==entity2);</span><br><span class="line">System.out.println(entity.equals(entity2));</span><br><span class="line"></span><br><span class="line">System.out.println(entity.equals(entity1));</span><br><span class="line">System.out.println(entity==entity1);</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><h3 id="equals-方法介绍"><a href="#equals-方法介绍" class="headerlink" title="equals()方法介绍"></a><strong>equals()方法介绍</strong></h3><p>Java中所有的类都是继承与Object这个基类的，在Object类中定义了一个equals方法，这个方法的初始行为是比较对象的内存地址，但在一些类库中已经重写了这个方法（一般都是用来比较对象的成员变量值是否相同），比如：String，Integer，Date 等类中，所以他们不再是比较类在堆中的地址了、</p><p>Object类中源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String类中重写后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == var1) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String var2 = (String)var1;</span><br><span class="line">                <span class="keyword">int</span> var3 = <span class="keyword">this</span>.value.length;</span><br><span class="line">                <span class="keyword">if</span> (var3 == var2.value.length) &#123;</span><br><span class="line">                    <span class="keyword">char</span>[] var4 = <span class="keyword">this</span>.value;</span><br><span class="line">                    <span class="keyword">char</span>[] var5 = var2.value;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var6 = <span class="number">0</span>; var3-- != <span class="number">0</span>; ++var6) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (var4[var6] != var5[var6]) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。</p><p> <strong>== 的作用：</strong><br>　　基本类型：比较的就是值是否相同<br>　　引用类型：比较的就是地址值是否相同<br><strong>equals 的作用:</strong><br>　　引用类型：默认情况下，比较的是地址值，重写该方法后比较对象的成员变量值是否相同</p><h2 id="String类的equals-方法"><a href="#String类的equals-方法" class="headerlink" title="String类的equals()方法"></a><strong>String类的equals()方法</strong></h2><p>JVM为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为<strong>字符串常量池。</strong>代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>;<span class="comment">// abc在常量池中</span></span><br><span class="line">String b = <span class="string">"abc"</span>;<span class="comment">//栈中b指向常量池中的abc</span></span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"abc"</span>);<span class="comment">// 在堆内存中重新开辟了一个abc的空间</span></span><br><span class="line">String d = c.intern();<span class="comment">//检查字符串池里是否存在"abc"这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把"abc"添加到字符串池中，然后再返回它的引用。</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">System.out.println(a==b);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line">System.out.println(a==c);</span><br><span class="line">System.out.println(a.equals(c));</span><br><span class="line">System.out.println(a==d);</span><br><span class="line">System.out.println(a.equals(d));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-12-18Java专项练习</title>
      <link href="/2020/8/"/>
      <url>/2020/8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-对于文件的一些描述"><a href="#1-对于文件的一些描述" class="headerlink" title="1.对于文件的一些描述"></a>1.对于文件的一些描述</h3><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E9%9B%86%E5%90%88/file.png" alt=""></p><p><code>A.文件分为文本文件和二进制文件，计算机只认识二进制，所以实际上都是二进制的不同解释方式。文本文件是以不同编码格式显示的字符，例如Ascii、Unicode等，window中文本文件的后缀名有&quot;.txt&quot;,&quot;.log&quot;,各种编程语言的源码文件等；二进制文件就是用文本文档打开是看不懂乱码，只要能用文本打开的文件都可以算是文本文件，只是显示的结果不是你想要的，二进制文件只有用特殊的应用才能读懂的文件，例如&quot;.png&quot;,&quot;.bmp&quot;等，计算机中大部分的文件还是二进制文件。</code></p><p><span style="color:red;"><code>B.File类是对文件整体或者文件属性操作的类，例如创建文件、删除文件、查看文件是否存在等功能，不能操作文件内容；文件内容是用IO流操作的。</code></span></p><p><code>C.当输入过程中意外到达文件或流的末尾时，抛出EOFException异常,正常情况下读取到文件末尾时，返回一个特殊值表示文件读取完成，例如read()返回-1表示文件读取完成。</code></p><p><code>D.上面A选项已经说了，不论是文本文件还是二进制文件，在计算机中都是以二进制形式存储的，所以都当做二进制文件读取。</code></p><h3 id="2-Servlet的生命周期"><a href="#2-Servlet的生命周期" class="headerlink" title="2.Servlet的生命周期"></a>2.Servlet的生命周期</h3><p>Servlet的生命周期分为5个阶段：<code>加载、创建、初始化、处理客户请求、卸载</code>。<br>(1)加载：Servlet容器（Tomcat）通过类加载器加载servlet文件（.class）<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源<br>servlet是由Servlet容器负责加载Servlet类，创建Servlet对象并实例化，然后调用Servlet的init方法，进行初始化，之后调用Service方法。实例化和初始化不同。先实例化，再初始化。</p><h3 id="3-父类和子类初始化过程"><a href="#3-父类和子类初始化过程" class="headerlink" title="3.父类和子类初始化过程"></a>3.父类和子类初始化过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E9%9B%86%E5%90%88/%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt=""></p><p>初始化过程是这样的： </p><p>1.首先，初始化父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； </p><p>2.然后，初始化子类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； </p><p>3.其次，初始化父类的普通成员变量和代码块，在执行父类的构造方法；</p><p>4.最后，初始化子类的普通成员变量和代码块，在执行子类的构造方法； </p><p>（1）初始化父类的普通成员变量和代码块，执行 <code>C c = new C();</code> 输出C </p><p>（2）<code>super(&quot;B&quot;);</code> 表示调用父类的构造方法，不调用父类的无参构造函数，输出B </p><p>（3） <code>System.out.print(&quot;B&quot;);</code> </p><p> 所以输出<code>CBB</code></p><h3 id="4-初始化子类需要注意的地方"><a href="#4-初始化子类需要注意的地方" class="headerlink" title="4.初始化子类需要注意的地方"></a>4.初始化子类需要注意的地方</h3><p>在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。</p><h3 id="5-StringBuilder、StringBuffer、String的比较"><a href="#5-StringBuilder、StringBuffer、String的比较" class="headerlink" title="5.StringBuilder、StringBuffer、String的比较"></a>5.StringBuilder、StringBuffer、String的比较</h3><p>首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：<code>StringBuilder &gt; StringBuffer &gt; String</code><br>String最慢的原因：</p><p>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。<br>String：适用于少量的字符串操作的情况</p><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p><p>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的。</p><h3 id="6-volatile关键字的两个作用"><a href="#6-volatile关键字的两个作用" class="headerlink" title="6.volatile关键字的两个作用"></a>6.volatile关键字的两个作用</h3><p>1.并发环境<span style="color:red;">可见性</span>：volatile修饰后的变量能够保证该变量在线程间的可见性，线程进行数据的读写操作时将绕开工作内存（CPU缓存）而直接跟主内存进行数据交互，即线程进行读操作时直接从主内存中读取，写操作时直接将修改后端变量刷新到主内存中，这样就能保证其他线程访问到的数据是最新数据 </p><p>  2.并发环境<span style="color:red;">有序性</span>：通过对volatile变量采取内存屏障（Memory barrier）的方式来防止编译重排序和CPU指令重排序，具体方式是通过在操作volatile变量的指令前后加入内存屏障，来实现happens-before关系，保证在多线程环境下的数据交互不会出现紊乱。</p><h3 id="7-for语句括号里的东西到底是啥意思"><a href="#7-for语句括号里的东西到底是啥意思" class="headerlink" title="7.for语句括号里的东西到底是啥意思"></a>7.for语句括号里的东西到底是啥意思</h3><p>for(1; 2; 3)</p><p>1.初始化语句，只会执行一次</p><p>2.循环终止控制，如果2的结果是false，循环就会终止</p><p>3.每次循环完毕的时候执行</p><h3 id="8-Java中的位运算符"><a href="#8-Java中的位运算符" class="headerlink" title="8.Java中的位运算符"></a>8.Java中的位运算符</h3><p>Java中的位运算符：</p><p><code>&gt;&gt;</code>表示右移，如果该数为正，则高位补0，若为负数，则高位补1；</p><p><code>&gt;&gt;&gt;</code>表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E9%9B%86%E5%90%88/%E4%BD%8D%E8%BF%90%E7%AE%97.png" alt=""></p><p>5的二进制是0101。</p><p>x=5&gt;&gt;2 （&gt;&gt;带符号右移）</p><p>将0101右移2位，为：0001。</p><p>y=x&gt;&gt;&gt;2 （&gt;&gt;&gt;无符号右移，左边空缺补充为0）</p><p>将0001右移2位，补0。结果为：0000。</p><p>所以得出答案0</p><h3 id="9-ThreadLocalMap使用开放定址法解决hash冲突，HashMap使用链地址法解决hash冲突"><a href="#9-ThreadLocalMap使用开放定址法解决hash冲突，HashMap使用链地址法解决hash冲突" class="headerlink" title="9.ThreadLocalMap使用开放定址法解决hash冲突，HashMap使用链地址法解决hash冲突"></a>9.ThreadLocalMap使用开放定址法解决hash冲突，HashMap使用链地址法解决hash冲突</h3><h3 id="10-线程调度"><a href="#10-线程调度" class="headerlink" title="10.线程调度"></a>10.线程调度</h3><p>线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p><h3 id="11-反射"><a href="#11-反射" class="headerlink" title="11.反射"></a>11.反射</h3><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E9%9B%86%E5%90%88/%E5%8F%8D%E5%B0%84.png" alt=""></p><p><strong><em>Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。</em></strong></p><p>A选项Class类位于lang包下面，D选项反射的本质就是从字节码中查找，动态获取类的整容结构，包括属性，构造器，动态调用对象的方法，而不是修剪类，F选项我觉得应该是，使用了反射的效率都会降低，就算加了缓存</p><h3 id="12-一个-java文件只能有一个public类"><a href="#12-一个-java文件只能有一个public类" class="headerlink" title="12.一个.java文件只能有一个public类"></a>12.一个.java文件只能有一个public类</h3><p>当编写一个java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元）。每个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。  </p><p>​                                                                                                                                 ——-《Java 编程思想》</p><h3 id="13-boolean和Boolean"><a href="#13-boolean和Boolean" class="headerlink" title="13.boolean和Boolean"></a>13.boolean和Boolean</h3>]]></content>
      
      
      <categories>
          
          <category> Java专项练习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公司二三事之挂载磁盘</title>
      <link href="/2020/7/"/>
      <url>/2020/7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：本文建议与下面两篇文章一起食用。<a href="https://www.cnblogs.com/kl876435928/p/7819565.html" target="_blank" rel="noopener">https://www.cnblogs.com/kl876435928/p/7819565.html</a>、<a href="https://xiejun.blog.csdn.net/article/details/52719171?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4.control" target="_blank" rel="noopener">https://xiejun.blog.csdn.net/article/details/52719171?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4.control</a></p></blockquote><p>今天公司的psql数据库启动不了，是因为放数据的文件夹没有挂载磁盘<br>然后我就去挂载了<br><code>mount /dev/sda4 /nfs</code><br>然后报错：要指定filesystem type<br><code>df -Th</code> 列出所有已挂载的磁盘包括文件系统类型（-T）<br>发现是ext4的<br><code>mount -t ext4 /dev/sda4 /nfs</code><br>还是报错：<img src="http://loc.dingtalk.com/QzpcVXNlcnNcQWRtaW5pc3RyYXRvclxBcHBEYXRhXFJvYW1pbmdcRGluZ1RhbGtcNzY4MTczODg0X3YyXEltYWdlRmlsZXNcMTYwNzkxOTQwMjg3M18zQ0Y4NkRDRS0wRURBLTQ3NTktQTcyMC1DQkYzMzA2MzE1RDIucG5n" alt="img"></p><p><code>dmesg | tail</code> </p><p>显示unable to read superblock</p><p><code>dumpe2fs /dev/sda4|more</code></p><p>显示找不到有效的文件系统超级块.</p><p>首先要找到superblock备份的几个位置，这需要利用mke2fs这个命令</p><p><code>mke2fs：create an ext2/ext3/ext4 filesystem</code></p><p>利用mke2fs这个命令 mke2fs -n 设备名,为了不引起歧义，所以这里直接复制了原文解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-n   Causes mke2fs to not actually create a filesystem, but display what it would do if it were to create</span><br><span class="line">        a filesystem. This can be used to determine the location of the backup superblocks for a particular</span><br><span class="line">        filesystem, so long as the mke2fs parameters that were passed when the filesystem was originally</span><br><span class="line">        created are used again. (With the -n option added, of course!)</span><br></pre></td></tr></table></figure><p>简单来说就是接了-n 参数 ，mke2fs 不是真的在设备上创建文件系统，它只是模拟这个过程并显示给你看。让你明白它究竟做了那些事。</p><p><code>mke2fs -n /dev/sda4</code>  //mke2fs其实是格式化分区，但是-n就是模拟的意思，这条命令的意思就是模拟一下格式化<code>/dev/sda4</code>这个磁盘会发生什么事。</p><p>但是却失败了</p><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mke2fs: inode_size (128) * inodes_count (0) too big for a</span><br><span class="line"> </span><br><span class="line">filesystem with 0 blocks, specify higher inode_ratio (-i)</span><br><span class="line"> </span><br><span class="line">or lower inode count (-N).</span><br></pre></td></tr></table></figure><p>出现这个错误意味着正在格式化一个扩展分区，直接格式化扩展分区是不允许的，只能格式化主分区和逻辑分区。那么应该如何格式化一个扩展分区呢？我们要么删除扩展分区创建一个主分区，要么在扩展分区上创建逻辑分区。</p><p>于是后面的事情都不用干了。</p><p>线索到这儿断了，又要去寻求别的办法了。</p><p>因为判断出是因为重启服务器导致之前挂载的磁盘掉了，现在本服务器的唯一一个没有被挂载的磁盘<code>/dev/sda4</code>其实不是真的没有被挂载，它是一个扩展分区，它上面创建了一个逻辑分区：<code>/dev/sda5</code>，而<code>sda5</code>已经被挂载在根目录/了，所以上面做的事情都是徒劳，但是对于磁盘的挂载有了一点认识，也不算徒劳。</p><p>然后又想到，既然不是在本服务器，会不会是在其他服务器上面呢？</p><p>未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
            <tag> Linux </tag>
            
            <tag> 挂载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何免费科学上网</title>
      <link href="/2020/4/"/>
      <url>/2020/4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：本文介绍的如何免费科学上网是通过一个网站<a href="https://xcat.us/" target="_blank" rel="noopener">xcat.us</a>来实现的，这个网站注册之后有免费三天vip可以用，之后过期了就要充值，最低是￥6元一个月，详情自己进去看。那么问题来了，如何长期免费用呢，聪明的小伙伴就发现了，可以通过不断注册新的帐号来使用，但是这个注册帐号是用邮箱接受验证码来注册的，如果你邮箱够多，那也能用一段时间了，但是现在很多邮箱都要用手机号码来注册，所以也实现不了长期使用啊，不可能每次用完了都去买个手机号，那还不如直接买6块一个月（个人感觉还是挺实惠的），所以我们就要用到不用手机号注册的邮箱了，这里我只找到了一种：<a href="https://mail.yandex.com/" target="_blank" rel="noopener">yandex</a>，其他一些临时邮箱这个网站能检测出来所以用不了。下面我们就来说说怎么注册这个yandex邮箱。</p></blockquote><h2 id="【1】进入yandex"><a href="#【1】进入yandex" class="headerlink" title="【1】进入yandex"></a><font color="red">【1】进入<a href="https://mail.yandex.com/" target="_blank" rel="noopener">yandex</a></font></h2><p>点击<code>Create an account</code></p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image-20200721161707377.png" alt=""></p><h2 id="【2】填信息"><a href="#【2】填信息" class="headerlink" title="【2】填信息"></a><font color="red">【2】填信息</font></h2><p>然后自己填信息，然后点击我没有手机号码</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image-20200721161905170.png" alt=""></p><p>然后会出现要你填验证码，而这个验证码非常反人类，我当初填了几十次都注册失败，明明填的跟他图片一模一样都是失败，后来才发现如果你fq了的话就非常容易成功了，这里说一下手机上有很多fq的app随便下一个能用的，大多数都有免费几天用，然后就注册成功了。如果不能fq的小伙伴就多试几次吧直到出现一个不分开两张图的可能就能成功了。</p><h2 id="【3】注册成功"><a href="#【3】注册成功" class="headerlink" title="【3】注册成功"></a><font color="red">【3】注册成功</font></h2><p>注册成功之后不要急着去xcat注册，最好先用你自己常用的邮箱发一份邮件试试能不能用，我第一次注册的时候就用不了，后面自己去发邮件到这个yandex邮箱的时候会被退信，然后重新注册一个yandex，先用自己邮箱测试能收件成功再去xcat注册，基本上都能收到验证码</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image-20200721162753338.png" alt=""></p><h2 id="【4】使用xcat"><a href="#【4】使用xcat" class="headerlink" title="【4】使用xcat"></a><font color="red">【4】使用xcat</font></h2><p>xcat的注册很简单，输入邮箱输入验证码就还有其他一些个人信息基本就行了，之后如何使用xcat在那个网站上都写得很清楚，这里我简单说一下。</p><h3 id="登录成功之后"><a href="#登录成功之后" class="headerlink" title="登录成功之后"></a><font color="blue">登录成功之后</font></h3><p>直接点击查看最新教程</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image-20200721163354400.png" alt=""></p><p>有电脑版的和手机版的（ios要先充值￥12元获得美区账号才能下载app，或者有账号的下载app要1.99刀，所以不推荐ios用户使用，毕竟不能白嫖）。</p><h3 id="电脑版：下载Clash"><a href="#电脑版：下载Clash" class="headerlink" title="电脑版：下载Clash"></a><font color="blue">电脑版：下载Clash</font></h3><p>下载下来是一个压缩文件直接解压，得到一个安装包直接右键管理员运行，然后安装 -&gt; 运行</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image-20200721164152659.png" alt=""></p><p>最后点击<code>Download</code>就可以了，接着按下图操作</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image-20200721164440039.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image-20200721164732070.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/image-20200721164933884.png" alt=""></p><p>然后到这里基本可以科学上网了，想要用安卓版的自己去看我没有安卓机所以没弄，然后其他有不懂的下方评论我看到会回复或者找那个网站的客服，有兴趣的小伙伴可以研究一下别的，本次介绍到此结束。</p>]]></content>
      
      
      <categories>
          
          <category> personal blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改Hexo博客主题</title>
      <link href="/2020/3/"/>
      <url>/2020/3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我的博客选择的主题是<a href="https://volantis.js.org/" target="_blank" rel="noopener">Volantis</a>，主要是把背景改成了代码雨，添加了打字特效，把评论系统从原来的valine改成了livere。第一次搭建博客主要参考了<a href="https://www.itrhx.com/" target="_blank" rel="noopener">itrhx.com</a>这位在官网看到的大佬博主。</p></blockquote><h2 id="代码雨背景"><a href="#代码雨背景" class="headerlink" title="代码雨背景"></a><font style="color: #1c92c4;">代码雨背景</font></h2><p>在博客上面添加代码雨背景只需要把原来的背景删掉，然后在<code>themes\volantis\layout.ejs</code>这个文件里面的body前面添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"1920"</span> <span class="attr">height</span>=<span class="string">"1080"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog@1.1/js/coderain.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>src里面的地址是代码雨的实现代码，我把它放在github上面用cdn加速访问了。</p><p>然后还要在<code>themes\volantis\source\css\_layout\main.styl</code>的末尾添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">canvas</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打字特效"><a href="#打字特效" class="headerlink" title="打字特效"></a><font style="color: #1c92c4;">打字特效</font></h2><p>直接在需要的地方添加代码，我把它放在了<code>themes\volantis\layout\_cover\index.ejs</code>里：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog@1.0/js/typed.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;div style=<span class="string">"text-align: center;font-weight: bold;color: #1c92c4;"</span>&gt;</span><br><span class="line">  &lt;span id="subtitle"&gt;&lt;/span&gt;</span><br><span class="line">  &lt;span id="typed-cursor"&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> typed = <span class="keyword">new</span> Typed(<span class="string">"#subtitle"</span>, &#123; strings: [<span class="string">"需要打出来的字"</span>], startDelay: <span class="number">1000</span>, typeSpeed: <span class="number">100</span>, loop: !<span class="number">0</span>, backSpeed: <span class="number">60</span>, backDelay: <span class="number">2000</span>, showCursor: !<span class="number">0</span> &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="把评论系统修改为livere"><a href="#把评论系统修改为livere" class="headerlink" title="把评论系统修改为livere"></a><font style="color: #1c92c4;">把评论系统修改为livere</font></h2><p>先去<a href="https://www.livere.com/city-demo" target="_blank" rel="noopener">livere官网</a>注册一个帐号，应该要用外网才能注册，直接去注册有可能成功，我点了好久糊里糊涂就成功了。注册成功之后点击安装，安装免费版的city就够用了。</p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/修改Hexo博客主题/1.png" alt="livere注册" style="zoom:80%;" /><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/%E4%BF%AE%E6%94%B9Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/2.png" alt="livere注册"></p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/修改Hexo博客主题/3.png" style="zoom:80%;" /><p>然后在<code>themes\volantis\layout\_partial</code>下面新建一个<code>livere.ejs</code>文件，文件的内容就是上面获取的代码。</p><p>然后把里面的评论部分代码修改成如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widget_id == <span class="string">'comments'</span>) &#123; %&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (post.comments)&#123; %&gt;</span><br><span class="line">      &lt;%- partial(<span class="string">'/livere'</span>) %&gt;</span><br><span class="line">    &lt;% &#125; <span class="keyword">else</span> &#123; %&gt;</span><br><span class="line">      &lt;div class="lv-container"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>此时<code>livere</code>已经添加OK了，重新部署博客然后刷新页面就可以看到博客中添加好了<code>livere</code>评论系统。</p><span class='p red'>遇到的问题：</span> <p>主题本身配置了很多种评论系统，包括现在这个<code>livere</code>，然后只需要配置一些参数，这里的<code>livere</code>只需要配置<code>uid</code>，然后把配置文件里面<code>comments</code>下的<code>service</code>改成<code>livere</code>就可以用这个评论系统了，但是有一个问题就是每次第一次进去评论框都会加载不出来，然后刷新一次才能加载出来，这实在是太让人抓狂(┬＿┬)，然后又去弄了一下<code>gitalk</code>，发现还是会有这个问题，无奈之下只能舍弃掉主题本身配置好的，然后自己重新配置加入新的代码，然后就成功了，不过到现在我也不知道是什么原因，毕竟我只是个小白，查到的代码看到哪里顺眼就放哪里，行就行了，不行再换个地方。</p><h2 id="用不蒜子添加网站运行时间、文章阅读数"><a href="#用不蒜子添加网站运行时间、文章阅读数" class="headerlink" title="用不蒜子添加网站运行时间、文章阅读数"></a><font style="color: #1c92c4;">用不蒜子添加网站运行时间、文章阅读数</font></h2><p>主题本身已经配置好了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>，只要在需要的地方加上代码就行了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span>本站总访问量<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span>本站访客数<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p><font color=red>注意：上面两行代码有所不同，pv是计算点击网站文章次数，uv只在进入网站的时候计算一次。添加完了之后要 <code>hexo d -g</code> 才会看到正确的数字，如果只是 <code>hexo s</code> 会看到一个很大的数字。</font></p>]]></content>
      
      
      <categories>
          
          <category> personal blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础学习之多线程（二）</title>
      <link href="/2020/6/"/>
      <url>/2020/6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：上次学到匿名内部类，接下来继续学习剩下的。文章内容是在b站学习多线程的笔记，视频地址<a href="https://www.bilibili.com/video/BV1uJ411k7wy?from=search&seid=3749706894771297867" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1uJ411k7wy?from=search&amp;seid=3749706894771297867</a></p></blockquote><h3 id="2-7-线程安全"><a href="#2-7-线程安全" class="headerlink" title="2.7 线程安全"></a>2.7 线程安全</h3><p>Q：什么是线程安全？</p><p>A：如果有多个线程在同时运行，并且这些线程都在运行同一段代码，程序每次运行的结果都和单线程运行的结果一样，就是线程安全的。</p><p>下面通过一个卖票的案例来演示线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一直卖票</span></span><br><span class="line">        <span class="comment">//while(true)为了避免死循环卡死电脑我改成循环100次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//如果有票</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第"</span> + ticket + <span class="string">"张票"</span>);<span class="comment">//卖票</span></span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20200724165311618.png" alt=""></p><p>发现程序出现了两个问题：</p><p>①卖出了相同的票数（如票6）。</p><p>②卖出了不存在的票（如票0）。</p><p>这种几个线程票数不同步的问题称为<strong>线程不安全</strong>。 </p><p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量（如示例中的ticket变量）、静态变量只有读操作，而无写 </p><p>操作（原子操作），一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， </p><p>否则的话就可能影响线程安全。 </p><h3 id="2-8-线程同步"><a href="#2-8-线程同步" class="headerlink" title="2.8 线程同步"></a>2.8 线程同步</h3><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p><p>要解决上述多线程并发访问同一个资源的安全性问题：也就是解决重复票与不存在票问题，Java中提供了同步机制（synchronized）来解决。</p><p>根据案例简述： </p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20200724170148705.png" alt=""></p><p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 </p><p>那么怎么去使用呢？有三种方式完成同步操作：</p><p>​    ①同步代码块</p><p>​    ②同步方法（静态同步方法）</p><p>​    ③锁机制</p><h4 id="2-8-1-同步代码块"><a href="#2-8-1-同步代码块" class="headerlink" title="2.8.1 同步代码块"></a>2.8.1 同步代码块</h4><p><code>synchronized</code>关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p><ul><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同步锁：</li></ul><p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。</p><p>①锁对象可以是任意类型。</p><p>②多个线程对象要使用同一把锁。</p><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 </p><p>(BLOCKED)。</p><p>实例代码（买票）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddSynTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一直卖票</span></span><br><span class="line">        <span class="comment">//while(true)为了避免死循环卡死电脑我改成for循环100次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//如果有票</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"在出售第"</span> + ticket + <span class="string">"张票"</span>);<span class="comment">//卖票</span></span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AddSynTicket addSynTicket = <span class="keyword">new</span> AddSynTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(addSynTicket).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(addSynTicket).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(addSynTicket).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/20200725103722.png" alt=""></p><p>可以看到线程问题已被解决。</p><h4 id="2-8-2-同步方法（静态同步方法）"><a href="#2-8-2-同步方法（静态同步方法）" class="headerlink" title="2.8.2 同步方法（静态同步方法）"></a>2.8.2 同步方法（静态同步方法）</h4><p>Q：什么叫同步方法？</p><p>A：使用<code>synchronized</code>修饰的方法就是同步方法，保证A线程执行该方法的时候，其他线程只能在方法外面等着。</p><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q：同步锁是谁？</p><p>A：对于非static方法，同步锁就是<code>new SynMethTicket</code>，也就是<code>this</code>；对于static方法，同步锁不能是<code>this</code>，<code>this</code>是创建对象之后产生的，静态方法优先于对象，静态同步方法的锁对象是我们使用当前方法所在类的<code>class</code>属性–&gt;<code>class文件对象</code>（反射）。</p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynMethTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*static*/</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一直卖票</span></span><br><span class="line">        <span class="comment">//while(true)为了避免死循环卡死电脑我改成循环100次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sellTicket2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//如果有票</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第(同步方法)"</span> + ticket + <span class="string">"张票"</span>);<span class="comment">//卖票</span></span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynMethTicket<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//有票,静态方法要用静态属性</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第(静态同步方法)"</span> + ticket + <span class="string">"张票"</span>);<span class="comment">//卖票</span></span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynMethTicket s = <span class="keyword">new</span> SynMethTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(s).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(s).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(s).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>synchronized</code>注释掉之后在方法里用同步代码块框住，同步方法的同步锁用<code>this</code>，静态同步方法的同步锁用<code>SynMethTicket.class</code>可以发现（静态）同步方法的同步锁就是这个。</p><h4 id="2-8-3-Lock锁"><a href="#2-8-3-Lock锁" class="headerlink" title="2.8.3 Lock锁"></a>2.8.3 Lock锁</h4><p><code>java.util.concurrent.locks.Lock</code>（接口）机制提供了比<code>synchronized</code>代码块和synchronized方法更广泛的锁定操作，同步代码块/同步方法具有的功能Lock都有，除此之外更强大，更体现面向对象。</p><p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p><ul><li><p><code>public void lock():</code>加同步锁。</p></li><li><p><code>public void unlock():释放同步锁。</code></p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20200725222446562.png" alt="JDK1.8API"></p></li></ul><p>示例代码①：（使用了Lock接口的实现类Reentrantlock）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Lock l = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一直卖票</span></span><br><span class="line">        <span class="comment">//while(true)为了避免死循环卡死电脑我改成循环100次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            l.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//如果有票</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第（lock）"</span> + ticket + <span class="string">"张票"</span>);<span class="comment">//卖票</span></span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">            l.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> LockTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码②：（jdk1.8api文档建议写法，注意finally）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Lock l = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一直卖票</span></span><br><span class="line">        <span class="comment">//while(true)为了避免死循环卡死电脑我改成循环100次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            l.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//如果有票</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第（lock）"</span> + ticket + <span class="string">"张票"</span>);<span class="comment">//卖票</span></span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    l.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> LockTicket();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-线程状态"><a href="#2-9-线程状态" class="headerlink" title="2.9 线程状态"></a>2.9 线程状态</h3><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/20200725224837.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%BE.bmp" alt=""></p><p>wait()和notify()/notifyAll()是Object类的方法。</p><h3 id="3-0-等待唤醒机制"><a href="#3-0-等待唤醒机制" class="headerlink" title="3.0 等待唤醒机制"></a>3.0 等待唤醒机制</h3><h4 id="3-1-线程间通信"><a href="#3-1-线程间通信" class="headerlink" title="3.1 线程间通信"></a>3.1 线程间通信</h4><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p><p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习git的使用</title>
      <link href="/2020/2/"/>
      <url>/2020/2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在B站上面学习了git的使用，现在把记录下来，视频链接：<a href="https://www.bilibili.com/video/BV1sJ411D7xN?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1sJ411D7xN?p=1</a></p></blockquote><h3 id="git的本地工作流程"><a href="#git的本地工作流程" class="headerlink" title="git的本地工作流程"></a>git的本地工作流程</h3><p>在本地的时候文件会经历以下三个地方，经过一系列的指令之后最终保存在本地仓库中。</p><p><img src="https://img-blog.csdnimg.cn/20200715142033890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1plcGhhbmlhaF8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200715142408940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1plcGhhbmlhaF8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>git init</code> 初始化仓库，让git知道它要管理这个仓库，生成隐藏文件.git<br><code>git status</code> 查看当前状态（工作区、缓存区、Git Repository本地仓库）<br><code>git add</code> 添加到缓存区<br><img src="https://img-blog.csdnimg.cn/20200715142701321.png" alt="在这里插入图片描述"><br><code>git commit -m &quot;提交说明/描述&quot;</code> 提交到本地仓库</p><h3 id="git的版本回退操作（时光穿梭机）"><a href="#git的版本回退操作（时光穿梭机）" class="headerlink" title="git的版本回退操作（时光穿梭机）"></a>git的版本回退操作（时光穿梭机）</h3><p><code>git log</code> 查看操作日志（显示作者、编号、当前版本、提交日期、提交注释）<br><code>git log --pretty=oneline</code> 查看操作日志（只显示编号、当前版本、提交注释）<br><code>git reset --hard 提交编号</code> 回溯到该编号的版本<br><code>git</code> <a href="http://dict.youdao.com/w/reflog" target="_blank" rel="noopener"><code>reflog</code></a> 由于git log只能看到当前以及之前的编号，所以要用到这个才能看到当前之后的编号，便于回溯到了之前又想回溯到之后的版本<br><code>mkdir 文件夹名</code> 创建文件夹<br><code>cd 文件地址</code> 进入文件夹<br><em>注意：编号可以不写全，但最好要写4位以上，避免以后编号多了会重复。</em></p><h3 id="基于https协议的github远程仓库的使用"><a href="#基于https协议的github远程仓库的使用" class="headerlink" title="基于https协议的github远程仓库的使用"></a>基于https协议的github远程仓库的使用</h3><p>在github创建了一个新的仓库之后可以看到地址（默认是https协议）：<br><img src="https://img-blog.csdnimg.cn/20200715150255196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1plcGhhbmlhaF8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>git clone 线上仓库地址</code> 克隆线上仓库到本地</p><p><code>git push</code> 修改完代码之后提交到本地仓库之后就使用该指令<strong>提交到线上仓库</strong>，但是要先在.git/config文件的url的//后面加上github的<code>用户名:密码@</code>，不然会提示权限不足（每天下班的最后一件事要<code>git push</code>）<br><code>git pull</code> 拉取线上仓库最新版本（每天上班的时候第一件事要<code>git pull</code>）</p><p><code>git remote add origin 线上仓库地址</code> 连接本地仓库和线上仓库</p><p><code>git push -u origin</code> 第一次连接仓库之后的push要这样写</p><p>由于每次使用git提交线上仓库的时候都要输入一次github的账号密码，这样很麻烦且不安全，所以就有了下面的ssh方式，只需要配置一次。</p><h3 id="基于ssh协议（推荐用这个）"><a href="#基于ssh协议（推荐用这个）" class="headerlink" title="基于ssh协议（推荐用这个）"></a>基于ssh协议（推荐用这个）</h3><p>基于ssh协议与https相比，只是影响github对于用户的身份鉴权方式，其他操作一模一样<br>点击Use SSH可以切换到ssh协议：<br><img src="https://img-blog.csdnimg.cn/20200715150535942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1plcGhhbmlhaF8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>生成公私钥对指令（需先自行安装OpenSSH）：<code>ssh-keygen -t rsa -C &quot;注册邮箱&quot;</code>（输入完这行代码之后一直回车就行了，然后他会显示公钥和私钥在哪个文件，自己去找到填在github上就行了）<br><strong>步骤:<br>1.生成客户端公私钥文件<br>2.将公钥上传到Github</strong><br>完了之后就可以克隆到本地啊，添加缓存区啊，提交本地仓库啊等等操作</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><img src="https://img-blog.csdnimg.cn/20200715123101176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1plcGhhbmlhaF8=,size_16,color_FFFFFF,t_70" alt="什么是分支">)<img src="https://img-blog.csdnimg.cn/202007151233515.png" alt="分支描述"><br>分支相关指令：<br>查看分支：<code>git branch</code><br>创建分支：<code>git branch 分支名</code><br>切换分支：<code>git checkout 分支名</code><br>删除分支：<code>git branch -d 分支名</code><br><em>注意：在删除分支的时候，一定要先退出要删除的分支，不然是删除不掉的。</em><br>合并分支：<code>git</code> <a href="https://fanyi.baidu.com/?aldtype=85#en/zh/merge" target="_blank" rel="noopener"><code>merge</code></a> <code>被合并的分支名</code><br><img src="https://img-blog.csdnimg.cn/20200715124038397.png" alt="在这里插入图片描述"></p><h3 id="冲突的产生与解决"><a href="#冲突的产生与解决" class="headerlink" title="冲突的产生与解决"></a>冲突的产生与解决</h3><p><strong>产生</strong>：在下班我<code>git push</code>之后，有同事修改了代码，然后我第二天上班没有<code>git pull</code>，而是直接修改代码，然后下班的时候<code>git push</code>就会产生冲突。<br><img src="https://img-blog.csdnimg.cn/20200715133537726.png" alt="在这里插入图片描述"><br><strong>解决</strong>：先git pull，然后系统会自动把线上仓库和本地仓库的冲突合并，然后我们需要和之前修改代码的同事商量该如何删除或保留这个合并之后的代码。最后商量好了就可以<code>git add</code> 、<code>git commit -m</code> 、<code>git push</code>了</p><h3 id="Git实用技能"><a href="#Git实用技能" class="headerlink" title="Git实用技能"></a>Git实用技能</h3><p>1、图形管理工具<br>①Github for Desktop<br><img src="https://img-blog.csdnimg.cn/20200715134708592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1plcGhhbmlhaF8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>②source tree<br><img src="https://img-blog.csdnimg.cn/20200715134745700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1plcGhhbmlhaF8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200715134805761.png" alt="在这里插入图片描述"><br>③TortoiseGit<br><img src="https://img-blog.csdnimg.cn/20200715134855479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1plcGhhbmlhaF8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>④装好git自带的，在非仓库的地方右键<code>Git GUI Here</code><br><img src="https://img-blog.csdnimg.cn/20200715135032209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1plcGhhbmlhaF8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p><img src="https://img-blog.csdnimg.cn/20200715135637342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1plcGhhbmlhaF8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>创建.gitignore文件：<br><img src="https://img-blog.csdnimg.cn/20200715140441348.png" alt="创建.gitignore文件"><br>写在.gitignore文件里：<br>1.<code>/mtk/</code>          过滤整个mtk文件夹<br>2.<code>*.zip</code>           过滤所有.zip文件<br>3.<code>/mtk/do.c</code>    过滤mtk文件夹下do.c文件<br>4.<code>!index.php</code> 不过滤index.php文件<br><em>在文件中以#开头的都是注释</em></p><h3 id="标签的使用"><a href="#标签的使用" class="headerlink" title="标签的使用"></a>标签的使用</h3><p><code>git tag 标签名（如v1.0）</code>创建一个标签</p><p><code>git push --tags</code> 提交的时候把标签也提交了</p><p><code>git checkout 标签名</code> 切换到该标签下的文件</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/1/"/>
      <url>/2020/1/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础学习之多线程（一）</title>
      <link href="/2020/5/"/>
      <url>/2020/5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：文章内容是在b站学习多线程的笔记，视频地址<a href="https://www.bilibili.com/video/BV1uJ411k7wy?from=search&seid=3749706894771297867" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1uJ411k7wy?from=search&amp;seid=3749706894771297867</a></p></blockquote><h2 id="【1】并发和并行"><a href="#【1】并发和并行" class="headerlink" title="【1】并发和并行"></a>【1】并发和并行</h2><p>并发：指两个或多个事件在同一个时间段内发生。</p><p>并行：指两个或多个事件在同一时刻发生（同时发生）。</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/bingxingyubingfa.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/02_%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.bmp" alt=""></p><h2 id="【2】进程和线程"><a href="#【2】进程和线程" class="headerlink" title="【2】进程和线程"></a>【2】进程和线程</h2><h3 id="2-1-进程和线程的概念"><a href="#2-1-进程和线程的概念" class="headerlink" title="2.1 进程和线程的概念"></a>2.1 进程和线程的概念</h3><ul><li><strong>进程：</strong>是指一个在内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/03_%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.bmp" alt=""></p><ul><li><strong>线程：</strong>线程是进程中的一个执行单元，负责当前进程中的程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/04_%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.bmp" alt=""></p><ul><li><p><strong>简而言之：</strong>一个程序运行后至少有一个进程，一个进程可以有多个线程。</p></li><li><p><strong>主线程：</strong>JVM执行main方法之后，main方法进入到栈内存，JVM会请求操作系统开辟一条从main方法到cpu的执行路径，cpu就可以通过这条路径执行main方法，而这条路径的名字就叫做main（主）线程。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/05_%E4%B8%BB%E7%BA%BF%E7%A8%8B.bmp" alt=""></p><h3 id="2-2-线程调度"><a href="#2-2-线程调度" class="headerlink" title="2.2 线程调度"></a>2.2 线程调度</h3><ul><li><strong>分时调度：</strong>所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。</li><li><strong>抢占式调度：</strong>优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），java使用的是抢占式调度。</li></ul><h3 id="2-3-创建线程方式一：继承Thread类"><a href="#2-3-创建线程方式一：继承Thread类" class="headerlink" title="2.3 创建线程方式一：继承Thread类"></a>2.3 创建线程方式一：继承Thread类</h3><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>代码如下：</p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这里是main线程！"</span>)</span><br><span class="line"><span class="comment">//创建自定义线程对象</span></span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//开启新线程</span></span><br><span class="line">mt.start();</span><br><span class="line"><span class="comment">//在主方法中执行for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"旺财"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"小强"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20200724111745526.png" alt=""></p><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的 start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。 通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。 </p><p>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明： </p><p>多线程执行时，在栈内存中，其实<strong>每一个执行线程都有一片自己所属的栈内存空间</strong>。进行方法的压栈和弹栈。 </p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20200724112223932.png" alt=""></p><p><strong>Thread类有关线程的一些方法：</strong></p><p><strong>构造方法：</strong></p><p><code>public Thread()</code> :分配一个新的线程对象。 </p><p><code>public Thread(String name)</code> :<font color="red">分配一个指定名字的新的线程对象。 </font></p><p><code>public Thread(Runnable target)</code> :分配一个带有指定目标新的线程对象。 </p><p><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。 </p><p><strong>常用方法：</strong> </p><p><code>public String getName()</code> : <font color="red">获取当前线程名称。</font></p><p><code>public void start()</code> :导致此线程开始执行; Java虚拟机调用此线程的run方法。 </p><p><code>public void run()</code> :此线程要执行的任务在此处定义代码。 </p><p><code>public static void sleep(long millis)</code> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 </p><p><code>public static Thread currentThread()</code> :<font color="red">返回对当前正在执行的线程对象的引用。 </font></p><h3 id="2-4-创建线程方式二：实现Runnable接口"><a href="#2-4-创建线程方式二：实现Runnable接口" class="headerlink" title="2.4 创建线程方式二：实现Runnable接口"></a>2.4 创建线程方式二：实现Runnable接口</h3><p>采用<code>java.lang.Runnable</code>也是非常常见的一种，我们只需要重写接口里面的<code>run</code>方法。</p><p>步骤如下：</p><p>​        ①新建一个类实现<code>Runnable</code>接口，并重写<code>run</code>方法，设置线程任务。</p><p>​        ②创建<code>Runnable</code>实现类的对象，并以此作为<code>Thread</code>类的构造方法的参数来实例化<code>Thread</code>对象，该Thread对象才是真正的线程对象。[<code>public Thread(Runnable target)</code> :分配一个带有指定目标新的线程对象。]</p><p>​        ③调用线程对象的<code>start()</code>方法来启动线程。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread.currentThread().getName()"</span>+<span class="string">"-&gt;"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span></span>&#123;</span><br><span class="line"><span class="comment">//创建Runnable实现类对象（线程任务对象）</span></span><br><span class="line">Runnable r = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"><span class="comment">//创建Thread线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.start();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">System.out.println(<span class="string">"Thread.currentThread().getName()"</span>+<span class="string">"-&gt;"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thread.currentThread().getName()</code>用来获取线程名称，因为<code>getName()</code>是<code>Thread</code>类的方法，所以其他类要调用Thread类的当前线程对象（<code>Thread.currentThread()</code>）再获取该对象的名字。</p><h3 id="2-5-使用Runnable接口创建线程的好处"><a href="#2-5-使用Runnable接口创建线程的好处" class="headerlink" title="2.5 使用Runnable接口创建线程的好处"></a>2.5 使用Runnable接口创建线程的好处</h3><ul><li><p><strong>避免了单继承的局限性：</strong>一个类只能继承一个类（一人只能有一个亲爹），类继承了Thread类就不能继承其他类了，实现了Runnable接口还可以继承其他类，实现其他的接口。</p></li><li><p><strong>增强了程序的扩展性，降低了程序的耦合性（解耦）</strong>：实现Runnable接口把设置线程任务和开启线程分离（解耦）。<strong>如果</strong>想要执行另外一种线程任务只需要新建一个实现类然后实例化这个类的对象传进Thread的构造方法即可，不需要调用start()方法重新开启一个线程；<strong>如果</strong>是继承Thread类的子类的话要执行另外一种线程任务就要新建一个子类，然后实例化对象，然后重新start()。</p><p><img src="https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog/images/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/20200724152436.png" alt=""></p></li></ul><h3 id="2-6-匿名内部类方式创建线程"><a href="#2-6-匿名内部类方式创建线程" class="headerlink" title="2.6 匿名内部类方式创建线程"></a>2.6 匿名内部类方式创建线程</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类/接口()&#123;</span><br><span class="line">重写父类/接口中的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"新建线程1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//继续简化</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"新建线程2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
