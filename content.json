{"meta":{"title":"Zephaniah.","subtitle":"","description":"","author":"Zephaniah.","url":"http://zpheak.tk","root":"/"},"pages":[{"title":"所有分类","date":"2020-07-16T12:19:58.840Z","updated":"2020-07-16T12:19:58.840Z","comments":true,"path":"categories/index.html","permalink":"http://zpheak.tk/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-07-16T12:07:44.555Z","updated":"2020-07-16T12:07:44.555Z","comments":true,"path":"about/index.html","permalink":"http://zpheak.tk/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有标签","date":"2020-07-16T12:19:53.544Z","updated":"2020-07-16T12:19:53.544Z","comments":true,"path":"tags/index.html","permalink":"http://zpheak.tk/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java中==和equals的区别","slug":"9","date":"2020-12-18T16:07:11.000Z","updated":"2020-12-18T16:11:35.463Z","comments":true,"path":"2020/9/","link":"","permalink":"http://zpheak.tk/2020/9/","excerpt":"","text":"转载自Java中equals和==的区别 背景介绍== 比较的是\\变量(栈)内存中存放的对象的(堆)内存地址，*用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。* \\equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。** java中的数据类型可以分为两类： 基本数据类型byte,short,char,int,long,float,double,boolean 基本数据类型之间的比较需要用双等号（==），因为他们比较的是值 引用数据类型接口、类、数组等非基本数据类型 Java中的字符串String属于引用数据类型。因为String是一个类 当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为没new一次就会重新开辟一个新的堆内存空间 123456789Entity entity = new Entity();Entity entity1 = new Entity();Entity entity2 = entity; System.out.println(entity==entity2);System.out.println(entity.equals(entity2));System.out.println(entity.equals(entity1));System.out.println(entity==entity1); 执行结果 1234truetruefalsefalse equals()方法介绍Java中所有的类都是继承与Object这个基类的，在Object类中定义了一个equals方法，这个方法的初始行为是比较对象的内存地址，但在一些类库中已经重写了这个方法（一般都是用来比较对象的成员变量值是否相同），比如：String，Integer，Date 等类中，所以他们不再是比较类在堆中的地址了、 Object类中源码 123public boolean equals(Object var1) &#123; return this == var1;&#125; String类中重写后的代码 123456789101112131415161718192021222324public boolean equals(Object var1) &#123; if (this == var1) &#123; return true; &#125; else &#123; if (var1 instanceof String) &#123; String var2 = (String)var1; int var3 = this.value.length; if (var3 == var2.value.length) &#123; char[] var4 = this.value; char[] var5 = var2.value; for(int var6 = 0; var3-- != 0; ++var6) &#123; if (var4[var6] != var5[var6]) &#123; return false; &#125; &#125; return true; &#125; &#125; return false; &#125; &#125; 总结：对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。 == 的作用： 基本类型：比较的就是值是否相同 引用类型：比较的就是地址值是否相同equals 的作用: 引用类型：默认情况下，比较的是地址值，重写该方法后比较对象的成员变量值是否相同 String类的equals()方法JVM为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为字符串常量池。代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。 123456789101112String a = \"abc\";// abc在常量池中String b = \"abc\";//栈中b指向常量池中的abcString c = new String(\"abc\");// 在堆内存中重新开辟了一个abc的空间String d = c.intern();//检查字符串池里是否存在\"abc\"这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把\"abc\"添加到字符串池中，然后再返回它的引用。 System.out.println(a==b);System.out.println(a.equals(b));System.out.println(a==c);System.out.println(a.equals(c));System.out.println(a==d);System.out.println(a.equals(d)); 123456truetruefalsetruetruetrue","categories":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/tags/Java/"}]},{"title":"2020-12-18Java专项练习","slug":"8","date":"2020-12-18T14:25:59.000Z","updated":"2020-12-18T14:54:34.060Z","comments":true,"path":"2020/8/","link":"","permalink":"http://zpheak.tk/2020/8/","excerpt":"","text":"1.对于文件的一些描述 A.文件分为文本文件和二进制文件，计算机只认识二进制，所以实际上都是二进制的不同解释方式。文本文件是以不同编码格式显示的字符，例如Ascii、Unicode等，window中文本文件的后缀名有&quot;.txt&quot;,&quot;.log&quot;,各种编程语言的源码文件等；二进制文件就是用文本文档打开是看不懂乱码，只要能用文本打开的文件都可以算是文本文件，只是显示的结果不是你想要的，二进制文件只有用特殊的应用才能读懂的文件，例如&quot;.png&quot;,&quot;.bmp&quot;等，计算机中大部分的文件还是二进制文件。 B.File类是对文件整体或者文件属性操作的类，例如创建文件、删除文件、查看文件是否存在等功能，不能操作文件内容；文件内容是用IO流操作的。 C.当输入过程中意外到达文件或流的末尾时，抛出EOFException异常,正常情况下读取到文件末尾时，返回一个特殊值表示文件读取完成，例如read()返回-1表示文件读取完成。 D.上面A选项已经说了，不论是文本文件还是二进制文件，在计算机中都是以二进制形式存储的，所以都当做二进制文件读取。 2.Servlet的生命周期Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。(1)加载：Servlet容器（Tomcat）通过类加载器加载servlet文件（.class）(2)创建：通过调用servlet构造函数创建一个servlet对象(3)初始化：调用init方法初始化(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求(5)卸载：调用destroy方法让servlet自己释放其占用的资源servlet是由Servlet容器负责加载Servlet类，创建Servlet对象并实例化，然后调用Servlet的init方法，进行初始化，之后调用Service方法。实例化和初始化不同。先实例化，再初始化。 3.父类和子类初始化过程 初始化过程是这样的： 1.首先，初始化父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 2.然后，初始化子类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 3.其次，初始化父类的普通成员变量和代码块，在执行父类的构造方法； 4.最后，初始化子类的普通成员变量和代码块，在执行子类的构造方法； （1）初始化父类的普通成员变量和代码块，执行 C c = new C(); 输出C （2）super(&quot;B&quot;); 表示调用父类的构造方法，不调用父类的无参构造函数，输出B （3） System.out.print(&quot;B&quot;); 所以输出CBB 4.初始化子类需要注意的地方在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。 5.StringBuilder、StringBuffer、String的比较首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; StringString最慢的原因： String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况 在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的。 6.volatile关键字的两个作用1.并发环境可见性：volatile修饰后的变量能够保证该变量在线程间的可见性，线程进行数据的读写操作时将绕开工作内存（CPU缓存）而直接跟主内存进行数据交互，即线程进行读操作时直接从主内存中读取，写操作时直接将修改后端变量刷新到主内存中，这样就能保证其他线程访问到的数据是最新数据 2.并发环境有序性：通过对volatile变量采取内存屏障（Memory barrier）的方式来防止编译重排序和CPU指令重排序，具体方式是通过在操作volatile变量的指令前后加入内存屏障，来实现happens-before关系，保证在多线程环境下的数据交互不会出现紊乱。 7.for语句括号里的东西到底是啥意思for(1; 2; 3) 1.初始化语句，只会执行一次 2.循环终止控制，如果2的结果是false，循环就会终止 3.每次循环完毕的时候执行 8.Java中的位运算符Java中的位运算符： &gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1； &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。 5的二进制是0101。 x=5&gt;&gt;2 （&gt;&gt;带符号右移） 将0101右移2位，为：0001。 y=x&gt;&gt;&gt;2 （&gt;&gt;&gt;无符号右移，左边空缺补充为0） 将0001右移2位，补0。结果为：0000。 所以得出答案0 9.ThreadLocalMap使用开放定址法解决hash冲突，HashMap使用链地址法解决hash冲突10.线程调度线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。 11.反射 Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。 A选项Class类位于lang包下面，D选项反射的本质就是从字节码中查找，动态获取类的整容结构，包括属性，构造器，动态调用对象的方法，而不是修剪类，F选项我觉得应该是，使用了反射的效率都会降低，就算加了缓存 12.一个.java文件只能有一个public类当编写一个java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元）。每个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。 ​ ——-《Java 编程思想》 13.boolean和Boolean","categories":[{"name":"Java专项练习笔记","slug":"Java专项练习笔记","permalink":"http://zpheak.tk/categories/Java%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/tags/Java/"}]},{"title":"公司二三事之挂载磁盘","slug":"7","date":"2020-12-16T09:24:21.000Z","updated":"2020-12-18T16:05:56.769Z","comments":true,"path":"2020/7/","link":"","permalink":"http://zpheak.tk/2020/7/","excerpt":"","text":"写在前面：本文建议与下面两篇文章一起食用。https://www.cnblogs.com/kl876435928/p/7819565.html、https://xiejun.blog.csdn.net/article/details/52719171?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4.control 今天公司的psql数据库启动不了，是因为放数据的文件夹没有挂载磁盘然后我就去挂载了mount /dev/sda4 /nfs然后报错：要指定filesystem typedf -Th 列出所有已挂载的磁盘包括文件系统类型（-T）发现是ext4的mount -t ext4 /dev/sda4 /nfs还是报错： dmesg | tail 显示unable to read superblock dumpe2fs /dev/sda4|more 显示找不到有效的文件系统超级块. 首先要找到superblock备份的几个位置，这需要利用mke2fs这个命令 mke2fs：create an ext2/ext3/ext4 filesystem 利用mke2fs这个命令 mke2fs -n 设备名,为了不引起歧义，所以这里直接复制了原文解释。 1234-n Causes mke2fs to not actually create a filesystem, but display what it would do if it were to create a filesystem. This can be used to determine the location of the backup superblocks for a particular filesystem, so long as the mke2fs parameters that were passed when the filesystem was originally created are used again. (With the -n option added, of course!) 简单来说就是接了-n 参数 ，mke2fs 不是真的在设备上创建文件系统，它只是模拟这个过程并显示给你看。让你明白它究竟做了那些事。 mke2fs -n /dev/sda4 //mke2fs其实是格式化分区，但是-n就是模拟的意思，这条命令的意思就是模拟一下格式化/dev/sda4这个磁盘会发生什么事。 但是却失败了 报错： 12345mke2fs: inode_size (128) * inodes_count (0) too big for a filesystem with 0 blocks, specify higher inode_ratio (-i) or lower inode count (-N). 出现这个错误意味着正在格式化一个扩展分区，直接格式化扩展分区是不允许的，只能格式化主分区和逻辑分区。那么应该如何格式化一个扩展分区呢？我们要么删除扩展分区创建一个主分区，要么在扩展分区上创建逻辑分区。 于是后面的事情都不用干了。 线索到这儿断了，又要去寻求别的办法了。 因为判断出是因为重启服务器导致之前挂载的磁盘掉了，现在本服务器的唯一一个没有被挂载的磁盘/dev/sda4其实不是真的没有被挂载，它是一个扩展分区，它上面创建了一个逻辑分区：/dev/sda5，而sda5已经被挂载在根目录/了，所以上面做的事情都是徒劳，但是对于磁盘的挂载有了一点认识，也不算徒劳。 然后又想到，既然不是在本服务器，会不会是在其他服务器上面呢？ 未完待续……","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zpheak.tk/categories/Linux/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://zpheak.tk/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"Linux","slug":"Linux","permalink":"http://zpheak.tk/tags/Linux/"},{"name":"挂载","slug":"挂载","permalink":"http://zpheak.tk/tags/%E6%8C%82%E8%BD%BD/"}]},{"title":"如何免费科学上网","slug":"4","date":"2020-07-21T08:53:21.000Z","updated":"2020-07-22T12:12:10.911Z","comments":true,"path":"2020/4/","link":"","permalink":"http://zpheak.tk/2020/4/","excerpt":"","text":"写在前面：本文介绍的如何免费科学上网是通过一个网站xcat.us来实现的，这个网站注册之后有免费三天vip可以用，之后过期了就要充值，最低是￥6元一个月，详情自己进去看。那么问题来了，如何长期免费用呢，聪明的小伙伴就发现了，可以通过不断注册新的帐号来使用，但是这个注册帐号是用邮箱接受验证码来注册的，如果你邮箱够多，那也能用一段时间了，但是现在很多邮箱都要用手机号码来注册，所以也实现不了长期使用啊，不可能每次用完了都去买个手机号，那还不如直接买6块一个月（个人感觉还是挺实惠的），所以我们就要用到不用手机号注册的邮箱了，这里我只找到了一种：yandex，其他一些临时邮箱这个网站能检测出来所以用不了。下面我们就来说说怎么注册这个yandex邮箱。 【1】进入yandex点击Create an account 【2】填信息然后自己填信息，然后点击我没有手机号码 然后会出现要你填验证码，而这个验证码非常反人类，我当初填了几十次都注册失败，明明填的跟他图片一模一样都是失败，后来才发现如果你fq了的话就非常容易成功了，这里说一下手机上有很多fq的app随便下一个能用的，大多数都有免费几天用，然后就注册成功了。如果不能fq的小伙伴就多试几次吧直到出现一个不分开两张图的可能就能成功了。 【3】注册成功注册成功之后不要急着去xcat注册，最好先用你自己常用的邮箱发一份邮件试试能不能用，我第一次注册的时候就用不了，后面自己去发邮件到这个yandex邮箱的时候会被退信，然后重新注册一个yandex，先用自己邮箱测试能收件成功再去xcat注册，基本上都能收到验证码 【4】使用xcatxcat的注册很简单，输入邮箱输入验证码就还有其他一些个人信息基本就行了，之后如何使用xcat在那个网站上都写得很清楚，这里我简单说一下。 登录成功之后直接点击查看最新教程 有电脑版的和手机版的（ios要先充值￥12元获得美区账号才能下载app，或者有账号的下载app要1.99刀，所以不推荐ios用户使用，毕竟不能白嫖）。 电脑版：下载Clash下载下来是一个压缩文件直接解压，得到一个安装包直接右键管理员运行，然后安装 -&gt; 运行 最后点击Download就可以了，接着按下图操作 然后到这里基本可以科学上网了，想要用安卓版的自己去看我没有安卓机所以没弄，然后其他有不懂的下方评论我看到会回复或者找那个网站的客服，有兴趣的小伙伴可以研究一下别的，本次介绍到此结束。","categories":[{"name":"personal blog","slug":"personal-blog","permalink":"http://zpheak.tk/categories/personal-blog/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://zpheak.tk/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}]},{"title":"修改Hexo博客主题","slug":"3","date":"2020-07-18T11:52:15.000Z","updated":"2020-07-22T12:12:32.038Z","comments":true,"path":"2020/3/","link":"","permalink":"http://zpheak.tk/2020/3/","excerpt":"","text":"我的博客选择的主题是Volantis，主要是把背景改成了代码雨，添加了打字特效，把评论系统从原来的valine改成了livere。第一次搭建博客主要参考了itrhx.com这位在官网看到的大佬博主。 代码雨背景在博客上面添加代码雨背景只需要把原来的背景删掉，然后在themes\\volantis\\layout.ejs这个文件里面的body前面添加以下代码： 12&lt;canvas id=\"canvas\" width=\"1920\" height=\"1080\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog@1.1/js/coderain.js\"&gt;&lt;/script&gt; src里面的地址是代码雨的实现代码，我把它放在github上面用cdn加速访问了。 然后还要在themes\\volantis\\source\\css\\_layout\\main.styl的末尾添加： 12345678910canvas &#123; position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1;&#125; 打字特效直接在需要的地方添加代码，我把它放在了themes\\volantis\\layout\\_cover\\index.ejs里： 12345678&lt;script src=\"https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog@1.0/js/typed.js\"&gt;&lt;/script&gt;&lt;div style=\"text-align: center;font-weight: bold;color: #1c92c4;\"&gt; &lt;span id=\"subtitle\"&gt;&lt;/span&gt; &lt;span id=\"typed-cursor\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var typed = new Typed(\"#subtitle\", &#123; strings: [\"需要打出来的字\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 &#125;)&lt;/script&gt; 把评论系统修改为livere先去livere官网注册一个帐号，应该要用外网才能注册，直接去注册有可能成功，我点了好久糊里糊涂就成功了。注册成功之后点击安装，安装免费版的city就够用了。 然后在themes\\volantis\\layout\\_partial下面新建一个livere.ejs文件，文件的内容就是上面获取的代码。 然后把里面的评论部分代码修改成如下： 123456&lt;% &#125; else if (widget_id == 'comments') &#123; %&gt; &lt;% if (post.comments)&#123; %&gt; &lt;%- partial('/livere') %&gt; &lt;% &#125; else &#123; %&gt; &lt;div class=\"lv-container\"&gt;&lt;/div&gt; &lt;% &#125; %&gt; 此时livere已经添加OK了，重新部署博客然后刷新页面就可以看到博客中添加好了livere评论系统。 遇到的问题： 主题本身配置了很多种评论系统，包括现在这个livere，然后只需要配置一些参数，这里的livere只需要配置uid，然后把配置文件里面comments下的service改成livere就可以用这个评论系统了，但是有一个问题就是每次第一次进去评论框都会加载不出来，然后刷新一次才能加载出来，这实在是太让人抓狂(┬＿┬)，然后又去弄了一下gitalk，发现还是会有这个问题，无奈之下只能舍弃掉主题本身配置好的，然后自己重新配置加入新的代码，然后就成功了，不过到现在我也不知道是什么原因，毕竟我只是个小白，查到的代码看到哪里顺眼就放哪里，行就行了，不行再换个地方。 用不蒜子添加网站运行时间、文章阅读数主题本身已经配置好了不蒜子，只要在需要的地方加上代码就行了 12&lt;span id=\"busuanzi_container_site_pv\"&gt;本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=\"busuanzi_container_site_uv\"&gt;本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人&lt;/span&gt; 注意：上面两行代码有所不同，pv是计算点击网站文章次数，uv只在进入网站的时候计算一次。添加完了之后要 hexo d -g 才会看到正确的数字，如果只是 hexo s 会看到一个很大的数字。","categories":[{"name":"personal blog","slug":"personal-blog","permalink":"http://zpheak.tk/categories/personal-blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zpheak.tk/tags/hexo/"},{"name":"博客主题","slug":"博客主题","permalink":"http://zpheak.tk/tags/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"}]},{"title":"Java基础学习之多线程（二）","slug":"6","date":"2020-07-16T12:32:22.000Z","updated":"2020-07-25T18:04:37.855Z","comments":true,"path":"2020/6/","link":"","permalink":"http://zpheak.tk/2020/6/","excerpt":"","text":"写在前面：上次学到匿名内部类，接下来继续学习剩下的。文章内容是在b站学习多线程的笔记，视频地址https://www.bilibili.com/video/BV1uJ411k7wy?from=search&amp;seid=3749706894771297867 2.7 线程安全Q：什么是线程安全？ A：如果有多个线程在同时运行，并且这些线程都在运行同一段代码，程序每次运行的结果都和单线程运行的结果一样，就是线程安全的。 下面通过一个卖票的案例来演示线程安全问题。 1234567891011121314151617181920212223242526public class Ticket implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; //一直卖票 //while(true)为了避免死循环卡死电脑我改成循环100次 for (int i = 0; i &lt; 100; i++) &#123; if (ticket &gt; 0) &#123;//如果有票 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在出售第\" + ticket + \"张票\");//卖票 ticket--; &#125; &#125; &#125; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(ticket).start(); new Thread(ticket).start(); new Thread(ticket).start(); &#125;&#125; 运行结果： 发现程序出现了两个问题： ①卖出了相同的票数（如票6）。 ②卖出了不存在的票（如票0）。 这种几个线程票数不同步的问题称为线程不安全。 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量（如示例中的ticket变量）、静态变量只有读操作，而无写 操作（原子操作），一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。 2.8 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 要解决上述多线程并发访问同一个资源的安全性问题：也就是解决重复票与不存在票问题，Java中提供了同步机制（synchronized）来解决。 根据案例简述： 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 那么怎么去使用呢？有三种方式完成同步操作： ​ ①同步代码块 ​ ②同步方法（静态同步方法） ​ ③锁机制 2.8.1 同步代码块synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式： 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁： 对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。 ①锁对象可以是任意类型。 ②多个线程对象要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 (BLOCKED)。 实例代码（买票） 1234567891011121314151617181920212223242526272829public class AddSynTicket implements Runnable &#123; private int ticket = 100; Object obj = new Object(); @Override public void run() &#123; //一直卖票 //while(true)为了避免死循环卡死电脑我改成for循环100次 for (int i = 0; i &lt; 100; i++) &#123; synchronized (obj)&#123; if (ticket &gt; 0) &#123;//如果有票 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"在出售第\" + ticket + \"张票\");//卖票 ticket--; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; AddSynTicket addSynTicket = new AddSynTicket(); new Thread(addSynTicket).start(); new Thread(addSynTicket).start(); new Thread(addSynTicket).start(); &#125;&#125; 运行结果： 可以看到线程问题已被解决。 2.8.2 同步方法（静态同步方法）Q：什么叫同步方法？ A：使用synchronized修饰的方法就是同步方法，保证A线程执行该方法的时候，其他线程只能在方法外面等着。 格式： 123public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; Q：同步锁是谁？ A：对于非static方法，同步锁就是new SynMethTicket，也就是this；对于static方法，同步锁不能是this，this是创建对象之后产生的，静态方法优先于对象，静态同步方法的锁对象是我们使用当前方法所在类的class属性–&gt;class文件对象（反射）。 实例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SynMethTicket implements Runnable &#123; private /*static*/ int ticket = 100; @Override public void run() &#123; //一直卖票 //while(true)为了避免死循环卡死电脑我改成循环100次 for (int i = 0; i &lt; 100; i++) &#123; sellTicket2(); &#125; &#125; public synchronized void sellTicket()&#123; if (ticket &gt; 0) &#123;//如果有票 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在出售第(同步方法)\" + ticket + \"张票\");//卖票 ticket--; &#125; &#125; public static synchronized void sellTicket2()&#123; synchronized (SynMethTicket.class)&#123; if (ticket &gt; 0) &#123;//有票,静态方法要用静态属性 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在出售第(静态同步方法)\" + ticket + \"张票\");//卖票 ticket--; &#125; &#125; &#125; public static void main(String[] args) &#123; SynMethTicket s = new SynMethTicket(); new Thread(s).start(); new Thread(s).start(); new Thread(s).start(); &#125;&#125; 将synchronized注释掉之后在方法里用同步代码块框住，同步方法的同步锁用this，静态同步方法的同步锁用SynMethTicket.class可以发现（静态）同步方法的同步锁就是这个。 2.8.3 Lock锁java.util.concurrent.locks.Lock（接口）机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作，同步代码块/同步方法具有的功能Lock都有，除此之外更强大，更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock():加同步锁。 public void unlock():释放同步锁。 示例代码①：（使用了Lock接口的实现类Reentrantlock） 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class LockTicket implements Runnable &#123; private int ticket = 100; Lock l = new ReentrantLock(); @Override public void run() &#123; //一直卖票 //while(true)为了避免死循环卡死电脑我改成循环100次 for (int i = 0; i &lt; 100; i++) &#123; l.lock(); if (ticket &gt; 0) &#123;//如果有票 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在出售第（lock）\" + ticket + \"张票\");//卖票 ticket--; &#125; l.unlock(); &#125; &#125; public static void main(String[] args) &#123; Runnable r = new LockTicket(); new Thread(r).start(); new Thread(r).start(); new Thread(r).start(); &#125;&#125; 示例代码②：（jdk1.8api文档建议写法，注意finally） 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class LockTicket implements Runnable &#123; private int ticket = 100; Lock l = new ReentrantLock(); @Override public void run() &#123; //一直卖票 //while(true)为了避免死循环卡死电脑我改成循环100次 for (int i = 0; i &lt; 100; i++) &#123; l.lock(); if (ticket &gt; 0) &#123;//如果有票 try &#123; Thread.sleep(10); System.out.println(Thread.currentThread().getName() + \"正在出售第（lock）\" + ticket + \"张票\");//卖票 ticket--; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; l.unlock(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Runnable r = new LockTicket(); new Thread(r).start(); new Thread(r).start(); new Thread(r).start(); &#125;&#125; 2.9 线程状态 wait()和notify()/notifyAll()是Object类的方法。 3.0 等待唤醒机制3.1 线程间通信概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。 比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。","categories":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://zpheak.tk/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"学习git的使用","slug":"2","date":"2020-07-15T19:16:08.000Z","updated":"2020-07-22T12:12:49.234Z","comments":true,"path":"2020/2/","link":"","permalink":"http://zpheak.tk/2020/2/","excerpt":"","text":"最近在B站上面学习了git的使用，现在把记录下来，视频链接：https://www.bilibili.com/video/BV1sJ411D7xN?p=1 git的本地工作流程在本地的时候文件会经历以下三个地方，经过一系列的指令之后最终保存在本地仓库中。 )git init 初始化仓库，让git知道它要管理这个仓库，生成隐藏文件.gitgit status 查看当前状态（工作区、缓存区、Git Repository本地仓库）git add 添加到缓存区git commit -m &quot;提交说明/描述&quot; 提交到本地仓库 git的版本回退操作（时光穿梭机）git log 查看操作日志（显示作者、编号、当前版本、提交日期、提交注释）git log --pretty=oneline 查看操作日志（只显示编号、当前版本、提交注释）git reset --hard 提交编号 回溯到该编号的版本git reflog 由于git log只能看到当前以及之前的编号，所以要用到这个才能看到当前之后的编号，便于回溯到了之前又想回溯到之后的版本mkdir 文件夹名 创建文件夹cd 文件地址 进入文件夹注意：编号可以不写全，但最好要写4位以上，避免以后编号多了会重复。 基于https协议的github远程仓库的使用在github创建了一个新的仓库之后可以看到地址（默认是https协议）：git clone 线上仓库地址 克隆线上仓库到本地 git push 修改完代码之后提交到本地仓库之后就使用该指令提交到线上仓库，但是要先在.git/config文件的url的//后面加上github的用户名:密码@，不然会提示权限不足（每天下班的最后一件事要git push）git pull 拉取线上仓库最新版本（每天上班的时候第一件事要git pull） git remote add origin 线上仓库地址 连接本地仓库和线上仓库 git push -u origin 第一次连接仓库之后的push要这样写 由于每次使用git提交线上仓库的时候都要输入一次github的账号密码，这样很麻烦且不安全，所以就有了下面的ssh方式，只需要配置一次。 基于ssh协议（推荐用这个）基于ssh协议与https相比，只是影响github对于用户的身份鉴权方式，其他操作一模一样点击Use SSH可以切换到ssh协议：生成公私钥对指令（需先自行安装OpenSSH）：ssh-keygen -t rsa -C &quot;注册邮箱&quot;（输入完这行代码之后一直回车就行了，然后他会显示公钥和私钥在哪个文件，自己去找到填在github上就行了）步骤:1.生成客户端公私钥文件2.将公钥上传到Github完了之后就可以克隆到本地啊，添加缓存区啊，提交本地仓库啊等等操作 分支管理)分支相关指令：查看分支：git branch创建分支：git branch 分支名切换分支：git checkout 分支名删除分支：git branch -d 分支名注意：在删除分支的时候，一定要先退出要删除的分支，不然是删除不掉的。合并分支：git merge 被合并的分支名 冲突的产生与解决产生：在下班我git push之后，有同事修改了代码，然后我第二天上班没有git pull，而是直接修改代码，然后下班的时候git push就会产生冲突。解决：先git pull，然后系统会自动把线上仓库和本地仓库的冲突合并，然后我们需要和之前修改代码的同事商量该如何删除或保留这个合并之后的代码。最后商量好了就可以git add 、git commit -m 、git push了 Git实用技能1、图形管理工具①Github for Desktop②source tree)③TortoiseGit④装好git自带的，在非仓库的地方右键Git GUI Here 忽略文件创建.gitignore文件：写在.gitignore文件里：1./mtk/ 过滤整个mtk文件夹2.*.zip 过滤所有.zip文件3./mtk/do.c 过滤mtk文件夹下do.c文件4.!index.php 不过滤index.php文件在文件中以#开头的都是注释 标签的使用git tag 标签名（如v1.0）创建一个标签 git push --tags 提交的时候把标签也提交了 git checkout 标签名 切换到该标签下的文件","categories":[{"name":"git","slug":"git","permalink":"http://zpheak.tk/categories/git/"},{"name":"github","slug":"github","permalink":"http://zpheak.tk/categories/github/"}],"tags":[{"name":"git","slug":"git","permalink":"http://zpheak.tk/tags/git/"}]},{"title":"Hello World","slug":"1","date":"2020-07-15T17:51:43.529Z","updated":"2020-07-22T12:17:21.783Z","comments":true,"path":"2020/1/","link":"","permalink":"http://zpheak.tk/2020/1/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Java基础学习之多线程（一）","slug":"5","date":"2020-07-15T11:02:17.000Z","updated":"2020-07-24T07:49:31.923Z","comments":true,"path":"2020/5/","link":"","permalink":"http://zpheak.tk/2020/5/","excerpt":"","text":"写在前面：文章内容是在b站学习多线程的笔记，视频地址https://www.bilibili.com/video/BV1uJ411k7wy?from=search&amp;seid=3749706894771297867 【1】并发和并行并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 【2】进程和线程2.1 进程和线程的概念 进程：是指一个在内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中的程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程可以有多个线程。 主线程：JVM执行main方法之后，main方法进入到栈内存，JVM会请求操作系统开辟一条从main方法到cpu的执行路径，cpu就可以通过这条路径执行main方法，而这条路径的名字就叫做main（主）线程。 2.2 线程调度 分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。 抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），java使用的是抢占式调度。 2.3 创建线程方式一：继承Thread类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： 12345678910111213public class Demo01 &#123; public static void main(String[] args) &#123; System.out.println(\"这里是main线程！\") //创建自定义线程对象 MyThread mt = new MyThread(); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"旺财\"+i); &#125; &#125;&#125; 自定义线程类： 1234567891011public class MyThread extends Thread &#123; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"小强\"+i); &#125; &#125;&#125; 流程图： 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的 start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。 通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。 多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明： 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 Thread类有关线程的一些方法： 构造方法： public Thread() :分配一个新的线程对象。 public Thread(String name) :分配一个指定名字的新的线程对象。 public Thread(Runnable target) :分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName() : 获取当前线程名称。 public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run() :此线程要执行的任务在此处定义代码。 public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread() :返回对当前正在执行的线程对象的引用。 2.4 创建线程方式二：实现Runnable接口采用java.lang.Runnable也是非常常见的一种，我们只需要重写接口里面的run方法。 步骤如下： ​ ①新建一个类实现Runnable接口，并重写run方法，设置线程任务。 ​ ②创建Runnable实现类的对象，并以此作为Thread类的构造方法的参数来实例化Thread对象，该Thread对象才是真正的线程对象。[public Thread(Runnable target) :分配一个带有指定目标新的线程对象。] ​ ③调用线程对象的start()方法来启动线程。 代码如下： 12345678public class MyRunnable implements Runnable&#123; @Override public void run()&#123; for(int i=0; i&lt;20; i++)&#123; System.out.println(\"Thread.currentThread().getName()\"+\"-&gt;\"+i); &#125; &#125;&#125; 12345678910public class Demo02&#123; //创建Runnable实现类对象（线程任务对象） Runnable r = new MyRunnable(); //创建Thread线程对象 Thread t = new Thread(r); t.start(); for(int i=0; i&lt;20; i++)&#123; System.out.println(\"Thread.currentThread().getName()\"+\"-&gt;\"+i); &#125;&#125; Thread.currentThread().getName()用来获取线程名称，因为getName()是Thread类的方法，所以其他类要调用Thread类的当前线程对象（Thread.currentThread()）再获取该对象的名字。 2.5 使用Runnable接口创建线程的好处 避免了单继承的局限性：一个类只能继承一个类（一人只能有一个亲爹），类继承了Thread类就不能继承其他类了，实现了Runnable接口还可以继承其他类，实现其他的接口。 增强了程序的扩展性，降低了程序的耦合性（解耦）：实现Runnable接口把设置线程任务和开启线程分离（解耦）。如果想要执行另外一种线程任务只需要新建一个实现类然后实例化这个类的对象传进Thread的构造方法即可，不需要调用start()方法重新开启一个线程；如果是继承Thread类的子类的话要执行另外一种线程任务就要新建一个子类，然后实例化对象，然后重新start()。 2.6 匿名内部类方式创建线程格式： 123new 父类/接口()&#123; 重写父类/接口中的方法&#125; 示例代码： 1234567891011121314151617181920public class Demo&#123; public static void main(String[] args)&#123; Runnable r = new Runnable()&#123; @Override public void run()&#123; System.out.println(\"新建线程1\"); &#125; &#125;; Thread t = new Thread(r); t.start(); //继续简化 new Thread(new Runnable()&#123; @Override public void run()&#123; System.out.println(\"新建线程2\"); &#125; &#125;).start(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://zpheak.tk/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/categories/Java/"},{"name":"Java专项练习笔记","slug":"Java专项练习笔记","permalink":"http://zpheak.tk/categories/Java%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Linux","slug":"Linux","permalink":"http://zpheak.tk/categories/Linux/"},{"name":"personal blog","slug":"personal-blog","permalink":"http://zpheak.tk/categories/personal-blog/"},{"name":"git","slug":"git","permalink":"http://zpheak.tk/categories/git/"},{"name":"github","slug":"github","permalink":"http://zpheak.tk/categories/github/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/tags/Java/"},{"name":"工作","slug":"工作","permalink":"http://zpheak.tk/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"Linux","slug":"Linux","permalink":"http://zpheak.tk/tags/Linux/"},{"name":"挂载","slug":"挂载","permalink":"http://zpheak.tk/tags/%E6%8C%82%E8%BD%BD/"},{"name":"科学上网","slug":"科学上网","permalink":"http://zpheak.tk/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"hexo","slug":"hexo","permalink":"http://zpheak.tk/tags/hexo/"},{"name":"博客主题","slug":"博客主题","permalink":"http://zpheak.tk/tags/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"},{"name":"多线程","slug":"多线程","permalink":"http://zpheak.tk/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"git","slug":"git","permalink":"http://zpheak.tk/tags/git/"}]}