{"meta":{"title":"Zephaniah.","subtitle":"","description":"","author":"Zephaniah.","url":"http://zpheak.tk","root":"/"},"pages":[{"title":"所有分类","date":"2020-07-16T12:19:58.840Z","updated":"2020-07-16T12:19:58.840Z","comments":true,"path":"categories/index.html","permalink":"http://zpheak.tk/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-07-16T12:07:44.555Z","updated":"2020-07-16T12:07:44.555Z","comments":true,"path":"about/index.html","permalink":"http://zpheak.tk/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有标签","date":"2020-07-16T12:19:53.544Z","updated":"2020-07-16T12:19:53.544Z","comments":true,"path":"tags/index.html","permalink":"http://zpheak.tk/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何免费科学上网","slug":"4","date":"2020-07-21T08:53:21.000Z","updated":"2020-07-22T12:12:10.911Z","comments":true,"path":"2020/4/","link":"","permalink":"http://zpheak.tk/2020/4/","excerpt":"","text":"写在前面：本文介绍的如何免费科学上网是通过一个网站xcat.us来实现的，这个网站注册之后有免费三天vip可以用，之后过期了就要充值，最低是￥6元一个月，详情自己进去看。那么问题来了，如何长期免费用呢，聪明的小伙伴就发现了，可以通过不断注册新的帐号来使用，但是这个注册帐号是用邮箱接受验证码来注册的，如果你邮箱够多，那也能用一段时间了，但是现在很多邮箱都要用手机号码来注册，所以也实现不了长期使用啊，不可能每次用完了都去买个手机号，那还不如直接买6块一个月（个人感觉还是挺实惠的），所以我们就要用到不用手机号注册的邮箱了，这里我只找到了一种：yandex，其他一些临时邮箱这个网站能检测出来所以用不了。下面我们就来说说怎么注册这个yandex邮箱。 【1】进入yandex点击Create an account 【2】填信息然后自己填信息，然后点击我没有手机号码 然后会出现要你填验证码，而这个验证码非常反人类，我当初填了几十次都注册失败，明明填的跟他图片一模一样都是失败，后来才发现如果你fq了的话就非常容易成功了，这里说一下手机上有很多fq的app随便下一个能用的，大多数都有免费几天用，然后就注册成功了。如果不能fq的小伙伴就多试几次吧直到出现一个不分开两张图的可能就能成功了。 【3】注册成功注册成功之后不要急着去xcat注册，最好先用你自己常用的邮箱发一份邮件试试能不能用，我第一次注册的时候就用不了，后面自己去发邮件到这个yandex邮箱的时候会被退信，然后重新注册一个yandex，先用自己邮箱测试能收件成功再去xcat注册，基本上都能收到验证码 【4】使用xcatxcat的注册很简单，输入邮箱输入验证码就还有其他一些个人信息基本就行了，之后如何使用xcat在那个网站上都写得很清楚，这里我简单说一下。 登录成功之后直接点击查看最新教程 有电脑版的和手机版的（ios要先充值￥12元获得美区账号才能下载app，或者有账号的下载app要1.99刀，所以不推荐ios用户使用，毕竟不能白嫖）。 电脑版：下载Clash下载下来是一个压缩文件直接解压，得到一个安装包直接右键管理员运行，然后安装 -&gt; 运行 最后点击Download就可以了，接着按下图操作 然后到这里基本可以科学上网了，想要用安卓版的自己去看我没有安卓机所以没弄，然后其他有不懂的下方评论我看到会回复或者找那个网站的客服，有兴趣的小伙伴可以研究一下别的，本次介绍到此结束。","categories":[{"name":"personal blog","slug":"personal-blog","permalink":"http://zpheak.tk/categories/personal-blog/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://zpheak.tk/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}]},{"title":"修改Hexo博客主题","slug":"3","date":"2020-07-18T11:52:15.000Z","updated":"2020-07-22T12:12:32.038Z","comments":true,"path":"2020/3/","link":"","permalink":"http://zpheak.tk/2020/3/","excerpt":"","text":"我的博客选择的主题是Volantis，主要是把背景改成了代码雨，添加了打字特效，把评论系统从原来的valine改成了livere。第一次搭建博客主要参考了itrhx.com这位在官网看到的大佬博主。 代码雨背景在博客上面添加代码雨背景只需要把原来的背景删掉，然后在themes\\volantis\\layout.ejs这个文件里面的body前面添加以下代码： 12&lt;canvas id=\"canvas\" width=\"1920\" height=\"1080\"&gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog@1.1/js/coderain.js\"&gt;&lt;/script&gt; src里面的地址是代码雨的实现代码，我把它放在github上面用cdn加速访问了。 然后还要在themes\\volantis\\source\\css\\_layout\\main.styl的末尾添加： 12345678910canvas &#123; position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1;&#125; 打字特效直接在需要的地方添加代码，我把它放在了themes\\volantis\\layout\\_cover\\index.ejs里： 12345678&lt;script src=\"https://cdn.jsdelivr.net/gh/Zephaniah-H/hexo-blog@1.0/js/typed.js\"&gt;&lt;/script&gt;&lt;div style=\"text-align: center;font-weight: bold;color: #1c92c4;\"&gt; &lt;span id=\"subtitle\"&gt;&lt;/span&gt; &lt;span id=\"typed-cursor\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var typed = new Typed(\"#subtitle\", &#123; strings: [\"需要打出来的字\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 &#125;)&lt;/script&gt; 把评论系统修改为livere先去livere官网注册一个帐号，应该要用外网才能注册，直接去注册有可能成功，我点了好久糊里糊涂就成功了。注册成功之后点击安装，安装免费版的city就够用了。 然后在themes\\volantis\\layout\\_partial下面新建一个livere.ejs文件，文件的内容就是上面获取的代码。 然后把里面的评论部分代码修改成如下： 123456&lt;% &#125; else if (widget_id == 'comments') &#123; %&gt; &lt;% if (post.comments)&#123; %&gt; &lt;%- partial('/livere') %&gt; &lt;% &#125; else &#123; %&gt; &lt;div class=\"lv-container\"&gt;&lt;/div&gt; &lt;% &#125; %&gt; 此时livere已经添加OK了，重新部署博客然后刷新页面就可以看到博客中添加好了livere评论系统。 遇到的问题： 主题本身配置了很多种评论系统，包括现在这个livere，然后只需要配置一些参数，这里的livere只需要配置uid，然后把配置文件里面comments下的service改成livere就可以用这个评论系统了，但是有一个问题就是每次第一次进去评论框都会加载不出来，然后刷新一次才能加载出来，这实在是太让人抓狂(┬＿┬)，然后又去弄了一下gitalk，发现还是会有这个问题，无奈之下只能舍弃掉主题本身配置好的，然后自己重新配置加入新的代码，然后就成功了，不过到现在我也不知道是什么原因，毕竟我只是个小白，查到的代码看到哪里顺眼就放哪里，行就行了，不行再换个地方。 用不蒜子添加网站运行时间、文章阅读数主题本身已经配置好了不蒜子，只要在需要的地方加上代码就行了 12&lt;span id=\"busuanzi_container_site_pv\"&gt;本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=\"busuanzi_container_site_uv\"&gt;本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人&lt;/span&gt; 注意：上面两行代码有所不同，pv是计算点击网站文章次数，uv只在进入网站的时候计算一次。添加完了之后要 hexo d -g 才会看到正确的数字，如果只是 hexo s 会看到一个很大的数字。","categories":[{"name":"personal blog","slug":"personal-blog","permalink":"http://zpheak.tk/categories/personal-blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zpheak.tk/tags/hexo/"},{"name":"博客主题","slug":"博客主题","permalink":"http://zpheak.tk/tags/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"}]},{"title":"Java基础学习之多线程（二）","slug":"6","date":"2020-07-16T12:32:22.000Z","updated":"2020-07-25T05:08:03.593Z","comments":true,"path":"2020/6/","link":"","permalink":"http://zpheak.tk/2020/6/","excerpt":"","text":"写在前面：上次学到匿名内部类，接下来继续学习剩下的。文章内容是在b站学习多线程的笔记，视频地址https://www.bilibili.com/video/BV1uJ411k7wy?from=search&amp;seid=3749706894771297867 2.7 线程安全Q：什么是线程安全？ A：如果有多个线程在同时运行，并且这些线程都在运行同一段代码，程序每次运行的结果都和单线程运行的结果一样，就是线程安全的。 下面通过一个卖票的案例来演示线程安全问题。 1234567891011121314151617181920212223242526public class Ticket implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; //一直卖票 //while(true)为了避免死循环卡死电脑我改成循环100次 for (int i = 0; i &lt; 100; i++) &#123; if (ticket &gt; 0) &#123;//如果有票 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在出售第\" + ticket + \"张票\");//卖票 ticket--; &#125; &#125; &#125; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(ticket).start(); new Thread(ticket).start(); new Thread(ticket).start(); &#125;&#125; 运行结果： 发现程序出现了两个问题： ①卖出了相同的票数（如票6）。 ②卖出了不存在的票（如票0）。 这种几个线程票数不同步的问题称为线程不安全。 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量（如示例中的ticket变量）、静态变量只有读操作，而无写 操作（原子操作），一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。 2.8 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 要解决上述多线程并发访问同一个资源的安全性问题：也就是解决重复票与不存在票问题，Java中提供了同步机制（synchronized）来解决。 根据案例简述： 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 那么怎么去使用呢？有三种方式完成同步操作： ​ ①同步代码块 ​ ②同步方法（静态同步方法） ​ ③锁机制 2.8.1 同步代码块synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式： 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁： 对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。 ①锁对象可以是任意类型。 ②多个线程对象要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 (BLOCKED)。 实例代码（买票） 1234567891011121314151617181920212223242526272829public class AddSynTicket implements Runnable &#123; private int ticket = 100; Object obj = new Object(); @Override public void run() &#123; //一直卖票 //while(true)为了避免死循环卡死电脑我改成for循环100次 for (int i = 0; i &lt; 100; i++) &#123; synchronized (obj)&#123; if (ticket &gt; 0) &#123;//如果有票 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"在出售第\" + ticket + \"张票\");//卖票 ticket--; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; AddSynTicket addSynTicket = new AddSynTicket(); new Thread(addSynTicket).start(); new Thread(addSynTicket).start(); new Thread(addSynTicket).start(); &#125;&#125; 运行结果： 可以看到线程问题已被解决。 2.8.2 同步方法（静态同步方法）Q：什么叫同步方法？ A：使用synchronized修饰的方法就是同步方法，保证A线程执行该方法的时候，其他线程只能在方法外面等着。 格式： 123public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; Q：同步锁是谁？ A：对于非static方法，同步锁就是this；对于static方法，同步锁就是我们使用当前方法所在类的字节码对象（类名.class）。 实例代码（同步方法）： 1234567891011121314151617181920212223242526272829303132public class SynMethTicket implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; //一直卖票 //while(true)为了避免死循环卡死电脑我改成循环100次 for (int i = 0; i &lt; 100; i++) &#123; sellTicket(); &#125; &#125; public synchronized void sellTicket()&#123; System.out.println(\"同步锁2\" +\" \"+ this); if (ticket &gt; 0) &#123;//如果有票 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在出售第(同步方法)\" + ticket + \"张票\");//卖票 ticket--; &#125; &#125; public static void main(String[] args) &#123; SynMethTicket s = new SynMethTicket(); System.out.println(\"同步锁1\" + \" \" + s); new Thread(s).start(); new Thread(s).start(); new Thread(s).start(); &#125;&#125; 运行结果： 图中可以看出线程问题已解决，而且同步锁this就是new SynMethTicket()。 示例代码（静态同步方法）： 12","categories":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://zpheak.tk/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"学习git的使用","slug":"2","date":"2020-07-15T19:16:08.000Z","updated":"2020-07-22T12:12:49.234Z","comments":true,"path":"2020/2/","link":"","permalink":"http://zpheak.tk/2020/2/","excerpt":"","text":"最近在B站上面学习了git的使用，现在把记录下来，视频链接：https://www.bilibili.com/video/BV1sJ411D7xN?p=1 git的本地工作流程在本地的时候文件会经历以下三个地方，经过一系列的指令之后最终保存在本地仓库中。 )git init 初始化仓库，让git知道它要管理这个仓库，生成隐藏文件.gitgit status 查看当前状态（工作区、缓存区、Git Repository本地仓库）git add 添加到缓存区git commit -m &quot;提交说明/描述&quot; 提交到本地仓库 git的版本回退操作（时光穿梭机）git log 查看操作日志（显示作者、编号、当前版本、提交日期、提交注释）git log --pretty=oneline 查看操作日志（只显示编号、当前版本、提交注释）git reset --hard 提交编号 回溯到该编号的版本git reflog 由于git log只能看到当前以及之前的编号，所以要用到这个才能看到当前之后的编号，便于回溯到了之前又想回溯到之后的版本mkdir 文件夹名 创建文件夹cd 文件地址 进入文件夹注意：编号可以不写全，但最好要写4位以上，避免以后编号多了会重复。 基于https协议的github远程仓库的使用在github创建了一个新的仓库之后可以看到地址（默认是https协议）：git clone 线上仓库地址 克隆线上仓库到本地 git push 修改完代码之后提交到本地仓库之后就使用该指令提交到线上仓库，但是要先在.git/config文件的url的//后面加上github的用户名:密码@，不然会提示权限不足（每天下班的最后一件事要git push）git pull 拉取线上仓库最新版本（每天上班的时候第一件事要git pull） git remote add origin 线上仓库地址 连接本地仓库和线上仓库 git push -u origin 第一次连接仓库之后的push要这样写 由于每次使用git提交线上仓库的时候都要输入一次github的账号密码，这样很麻烦且不安全，所以就有了下面的ssh方式，只需要配置一次。 基于ssh协议（推荐用这个）基于ssh协议与https相比，只是影响github对于用户的身份鉴权方式，其他操作一模一样点击Use SSH可以切换到ssh协议：生成公私钥对指令（需先自行安装OpenSSH）：ssh-keygen -t rsa -C &quot;注册邮箱&quot;（输入完这行代码之后一直回车就行了，然后他会显示公钥和私钥在哪个文件，自己去找到填在github上就行了）步骤:1.生成客户端公私钥文件2.将公钥上传到Github完了之后就可以克隆到本地啊，添加缓存区啊，提交本地仓库啊等等操作 分支管理)分支相关指令：查看分支：git branch创建分支：git branch 分支名切换分支：git checkout 分支名删除分支：git branch -d 分支名注意：在删除分支的时候，一定要先退出要删除的分支，不然是删除不掉的。合并分支：git merge 被合并的分支名 冲突的产生与解决产生：在下班我git push之后，有同事修改了代码，然后我第二天上班没有git pull，而是直接修改代码，然后下班的时候git push就会产生冲突。解决：先git pull，然后系统会自动把线上仓库和本地仓库的冲突合并，然后我们需要和之前修改代码的同事商量该如何删除或保留这个合并之后的代码。最后商量好了就可以git add 、git commit -m 、git push了 Git实用技能1、图形管理工具①Github for Desktop②source tree)③TortoiseGit④装好git自带的，在非仓库的地方右键Git GUI Here 忽略文件创建.gitignore文件：写在.gitignore文件里：1./mtk/ 过滤整个mtk文件夹2.*.zip 过滤所有.zip文件3./mtk/do.c 过滤mtk文件夹下do.c文件4.!index.php 不过滤index.php文件在文件中以#开头的都是注释 标签的使用git tag 标签名（如v1.0）创建一个标签 git push --tags 提交的时候把标签也提交了 git checkout 标签名 切换到该标签下的文件","categories":[{"name":"git","slug":"git","permalink":"http://zpheak.tk/categories/git/"},{"name":"github","slug":"github","permalink":"http://zpheak.tk/categories/github/"}],"tags":[{"name":"git","slug":"git","permalink":"http://zpheak.tk/tags/git/"}]},{"title":"Hello World","slug":"1","date":"2020-07-15T17:51:43.529Z","updated":"2020-07-22T12:17:21.783Z","comments":true,"path":"2020/1/","link":"","permalink":"http://zpheak.tk/2020/1/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Java基础学习之多线程（一）","slug":"5","date":"2020-07-15T11:02:17.000Z","updated":"2020-07-24T07:49:31.923Z","comments":true,"path":"2020/5/","link":"","permalink":"http://zpheak.tk/2020/5/","excerpt":"","text":"写在前面：文章内容是在b站学习多线程的笔记，视频地址https://www.bilibili.com/video/BV1uJ411k7wy?from=search&amp;seid=3749706894771297867 【1】并发和并行并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 【2】进程和线程2.1 进程和线程的概念 进程：是指一个在内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中的程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程可以有多个线程。 主线程：JVM执行main方法之后，main方法进入到栈内存，JVM会请求操作系统开辟一条从main方法到cpu的执行路径，cpu就可以通过这条路径执行main方法，而这条路径的名字就叫做main（主）线程。 2.2 线程调度 分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。 抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），java使用的是抢占式调度。 2.3 创建线程方式一：继承Thread类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： 12345678910111213public class Demo01 &#123; public static void main(String[] args) &#123; System.out.println(\"这里是main线程！\") //创建自定义线程对象 MyThread mt = new MyThread(); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"旺财\"+i); &#125; &#125;&#125; 自定义线程类： 1234567891011public class MyThread extends Thread &#123; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"小强\"+i); &#125; &#125;&#125; 流程图： 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的 start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。 通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。 多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明： 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 Thread类有关线程的一些方法： 构造方法： public Thread() :分配一个新的线程对象。 public Thread(String name) :分配一个指定名字的新的线程对象。 public Thread(Runnable target) :分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName() : 获取当前线程名称。 public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run() :此线程要执行的任务在此处定义代码。 public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread() :返回对当前正在执行的线程对象的引用。 2.4 创建线程方式二：实现Runnable接口采用java.lang.Runnable也是非常常见的一种，我们只需要重写接口里面的run方法。 步骤如下： ​ ①新建一个类实现Runnable接口，并重写run方法，设置线程任务。 ​ ②创建Runnable实现类的对象，并以此作为Thread类的构造方法的参数来实例化Thread对象，该Thread对象才是真正的线程对象。[public Thread(Runnable target) :分配一个带有指定目标新的线程对象。] ​ ③调用线程对象的start()方法来启动线程。 代码如下： 12345678public class MyRunnable implements Runnable&#123; @Override public void run()&#123; for(int i=0; i&lt;20; i++)&#123; System.out.println(\"Thread.currentThread().getName()\"+\"-&gt;\"+i); &#125; &#125;&#125; 12345678910public class Demo02&#123; //创建Runnable实现类对象（线程任务对象） Runnable r = new MyRunnable(); //创建Thread线程对象 Thread t = new Thread(r); t.start(); for(int i=0; i&lt;20; i++)&#123; System.out.println(\"Thread.currentThread().getName()\"+\"-&gt;\"+i); &#125;&#125; Thread.currentThread().getName()用来获取线程名称，因为getName()是Thread类的方法，所以其他类要调用Thread类的当前线程对象（Thread.currentThread()）再获取该对象的名字。 2.5 使用Runnable接口创建线程的好处 避免了单继承的局限性：一个类只能继承一个类（一人只能有一个亲爹），类继承了Thread类就不能继承其他类了，实现了Runnable接口还可以继承其他类，实现其他的接口。 增强了程序的扩展性，降低了程序的耦合性（解耦）：实现Runnable接口把设置线程任务和开启线程分离（解耦）。如果想要执行另外一种线程任务只需要新建一个实现类然后实例化这个类的对象传进Thread的构造方法即可，不需要调用start()方法重新开启一个线程；如果是继承Thread类的子类的话要执行另外一种线程任务就要新建一个子类，然后实例化对象，然后重新start()。 2.6 匿名内部类方式创建线程格式： 123new 父类/接口()&#123; 重写父类/接口中的方法&#125; 示例代码： 1234567891011121314151617181920public class Demo&#123; public static void main(String[] args)&#123; Runnable r = new Runnable()&#123; @Override public void run()&#123; System.out.println(\"新建线程1\"); &#125; &#125;; Thread t = new Thread(r); t.start(); //继续简化 new Thread(new Runnable()&#123; @Override public void run()&#123; System.out.println(\"新建线程2\"); &#125; &#125;).start(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://zpheak.tk/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}],"categories":[{"name":"personal blog","slug":"personal-blog","permalink":"http://zpheak.tk/categories/personal-blog/"},{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/categories/Java/"},{"name":"git","slug":"git","permalink":"http://zpheak.tk/categories/git/"},{"name":"github","slug":"github","permalink":"http://zpheak.tk/categories/github/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://zpheak.tk/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"hexo","slug":"hexo","permalink":"http://zpheak.tk/tags/hexo/"},{"name":"博客主题","slug":"博客主题","permalink":"http://zpheak.tk/tags/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"},{"name":"Java","slug":"Java","permalink":"http://zpheak.tk/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://zpheak.tk/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"git","slug":"git","permalink":"http://zpheak.tk/tags/git/"}]}